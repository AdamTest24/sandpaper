% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils-git.R
\name{git_worktree_setup}
\alias{git_worktree_setup}
\title{Setup a git worktree for concurrent manipulation of a separate branch}
\usage{
git_worktree_setup(
  path = ".",
  dest_dir,
  branch = "gh-pages",
  remote = "origin",
  throwaway = FALSE
)
}
\arguments{
\item{path}{path to the repository}

\item{dest_dir}{path to the destination directory to contain the work tree}

\item{branch}{the branch associated with the work tree (default: gh-pages)}

\item{remote}{the remote name (default: origin)}

\item{throwaway}{if \code{TRUE}, the worktree created is in a detached HEAD state
from from the remote branch and will not create a new branch in your
repository. Defaults to \code{FALSE}, which will create the branch from upstream.}
}
\value{
an \code{\link[=expression]{expression()}} that calls \verb{git worktree remove} on the worktree
when evaluated.
}
\description{
Setup a git worktree for concurrent manipulation of a separate branch
}
\details{
This function is used in continuous integration settings where we want to
push derived outputs to non-main branches in our repository. We use this to
populate the markdown and HTML outputs from the lesson so that we don't have
to rebuild the lesson from scratch every time.

The logic behind this looks like\preformatted{worktree setup
[IF BRANCH DOES NOT EXIST]
  git checkout --orphan <branch>
  git rm -rf --quiet .
  git commit --allow-empty -m
  git push remote HEAD:<branch>
  git checkout -
git fetch <remote> +refs/heads/<branch>:refs/remotes/<remote>/<branch>
git worktree add --track -B <branch> /path/to/dir <remote>/<branch>
}
}
\note{
this internal function has been modified from the logic in
\code{\link[pkgdown:deploy_to_branch]{pkgdown::deploy_to_branch()}}, by Hadley Wickham.
}
\examples{
if (sandpaper:::has_git() && requireNamespace("withr", quietly = TRUE)) {
cli::cli_h1("Set up")
cli::cli_h2("Create Lesson")
restore_fixture <- sandpaper:::create_test_lesson()
sandpaper:::check_git_user()
res <- getOption("sandpaper.test_fixture")
cli::cli_h2("Create Remote")
rmt <- fs::file_temp(pattern = "REMOTE-")
sandpaper:::setup_local_remote(repo = res, remote = rmt, verbose = FALSE)
cli::cli_h2("Create Worktrees")
db <- sandpaper:::git_worktree_setup(res, fs::path(res, "site", "built"), 
  branch = "md-outputs", remote = "sandpaper-local"
)
ds <- sandpaper:::git_worktree_setup(res, fs::path(res, "site", "docs"), 
  branch = "gh-pages", remote = "sandpaper-local"
)
cli::cli_h1("Build Lesson into worktrees")
build_lesson(res, quiet = TRUE, preview = FALSE)
cli::cli_h2("git status: {gert::git_branch(repo = res)}")
print(gert::git_status(repo = res))
cli::cli_h2('git status: {gert::git_branch(repo = fs::path(res, "site", "built"))}')
print(gert::git_status(repo = fs::path(res, "site", "built")))
cli::cli_h2('git status: {gert::git_branch(repo = fs::path(res, "site", "docs"))}')
print(gert::git_status(repo = fs::path(res, "site", "docs")))
cli::cli_h1("Clean Up")
eval(db)
eval(ds)
sandpaper:::remove_local_remote(repo = res)
sandpaper:::reset_git_user(res)
# remove the test fixture and report
tryCatch(fs::dir_delete(res), error = function() FALSE)
}
}
\keyword{internal}
