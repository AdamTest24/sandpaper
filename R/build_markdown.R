#' Build plain markdown from the RMarkdown episodes
#'
#' In the spirit of {hugodown}, This function will build plain markdown files
#' as a minimal R package in the `site/` folder of your {sandpaper} lesson
#' repository tagged with the hash of your file to ensure that only files that
#' have changed are rebuilt. 
#' 
#' @param path the path to your repository (defaults to your current working
#' directory)
#' @param rebuild if `TRUE`, everything will be built from scratch as if there
#' was no cache. Defaults to `FALSE`, which will only build markdown files that
#' haven't been built before. 
#' 
#' @return `TRUE` if it was successful, a character vector of issues if it was
#'   unsuccessful.
#' 
#' @keywords internal
#' @seealso [build_episode_md()]
build_markdown <- function(path = ".", rebuild = FALSE, quiet = FALSE) {

  episode_path <- path_episodes(path)
  outdir       <- path_built()

  # Determine build status for the episodes ------------------------------------
  source_list    <- get_resource_list(path)
  sources        <- unlist(source_list, use.names = FALSE)
  names(sources) <- get_slug(sources)

  # If the user accidentally used rmarkdown::render(), then they would end up
  # with an html artifact in here and it will clog up the machinery. Best to 
  # remove it at the source.
  remove_rendered_html(sources)

  db_path <- fs::path(outdir, "md5sum.txt")
  db <- build_status(sources, db_path, rebuild, write = FALSE)
  update <- FALSE

  on.exit({
    if (update) write_build_db(db$new, db_path)
  }, add = TRUE)

  # Copy the files to the assets directory -------------------------------------
  artifacts <- get_artifacts(path, "episodes")
  to_copy <- vapply(
    c("data", "files", "fig"), 
    FUN = function(i) enforce_dir(fs::path(episode_path, i)),
    FUN.VALUE = character(1)
  )
  to_copy <- c(to_copy, artifacts)
  for (f in to_copy) {
    copy_assets(f, outdir)
  }

  # Render the episode files to the built directory ----------------------------
  for (i in seq_along(db$build)) {
    build_episode_md(
      path    = db$build[i],
      outdir  = outdir,
      workdir = outdir,
      quiet   = quiet
    )
  }

  # Remove detritus ------------------------------------------------------------
  remove <- db$remove
  if (length(remove)) {
    # Remove previously built files
    fs::file_delete(remove)
    # Also remove any figures generated by those files
    for (built_slug in get_slug(remove)) {
      figs <- get_figs(path, built_slug)
      if (length(figs)) fs::file_delete(figs)
    }
  }

  # Update metadata ------------------------------------------------------------
  if (length(db$build) > 0) {
    update_site_timestamp(path)
  }

  # Update the navbar ----------------------------------------------------------
  update_site_menu(path,
    episodes    = source_list$episodes,
    learners    = source_list$learners,
    instructors = source_list$instructors,
    profiles    = source_list$profiles
  )
  # We've made it this far, so the database can be updated

  update <- TRUE
  invisible(db$build)
}



remove_rendered_html <- function(episodes) {
  htmls <- fs::path_ext_set(episodes, "html")
  exists <- fs::file_exists(htmls)
  if (any(exists)) {
    fs::file_delete(unique(htmls[exists]))
  }
}



